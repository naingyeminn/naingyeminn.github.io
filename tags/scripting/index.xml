<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Scripting on Naing Ye` Minn </title>
    <link>http://naingyeminn.com/tags/scripting/</link>
    <language>en-us</language>
    <author>Naing Ye` Minn</author>
    <updated>2018-11-21 00:00:00 &#43;0000 UTC</updated>
    
    <item>
      <title>Managing RHEL5 with Ansible</title>
      <link>http://naingyeminn.com/posts/managing-rhel5-with-ansible/</link>
      <pubDate>Wed, 21 Nov 2018 00:00:00 UTC</pubDate>
      <author>Naing Ye` Minn</author>
      <guid>http://naingyeminn.com/posts/managing-rhel5-with-ansible/</guid>
      <description>&lt;p&gt;လွန်ခဲ့တဲ့ တစ်ပတ်လောက်က မိတ်ဆွေအကိုတွေနဲ့အလုပ်ကိစ္စစကားထိုင်ပြောနေရင်း Ansible အကြောင်းရောက်သွားတယ်။ သူတို့ရုံးရဲ့ Server တွေကို Ansible နဲ့ စမ်းပြီး Manage လုပ်ကြည့်နေတာမှာ ကြုံရတဲ့ ပြဿနာတစ်ခုကိုပြောပြတယ်။ သုံးထားတဲ့ Server OS တွေက RHEL 5, 6, 7 အစုံဖြစ်နေတာကြောင့် Playbook တစ်ခုတည်းနဲ့ ပေါင်းပြီး run လိုက်တဲ့အခါကျ version အနိမ့်ဖြစ်တဲ့ RHEL 5 မှာအဆင်မပြေပဲ error တွေတက်တာပါ။ အဲ့ဒီတုန်းကတော့ connection type (Paramiko ကိုသုံးဖို့လိုတာ) ကြောင့်လို့ပဲထင်လိုက်မိတာ တကယ်တမ်းသေချာအောင် လိုက်ရှာဖတ်ကြည့်တော့မှ Ansible Version နဲ့ Managed Node ရဲ့ Python Version နဲ့မကိုက်တာကြောင့်မှန်းသိရတယ်။ အဲ့တော့ ဒီပြဿနာကိုဖြေရှင်းဖို့က နည်းလမ်း သုံးခုတော့ရှိပါတယ်။ (၁) Ansible Version အနိမ့်နဲ့ Manage လုပ်ရင်လုပ်၊ (၂) Managed Node ရဲ့ Python ကို Version မြှင့်ရင်မြှင့်၊ (၃) Ansible ရဲ့ Python မလိုတဲ့ RAW Module နဲ့ Script Module ကိုသုံးရင်သုံး၊ ဒီနည်းလမ်းတွေနဲ့ဖြေရှင်းလို့ရပါတယ်။&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;(၁)&lt;/strong&gt; Ansible Version အနိမ့်နဲ့ Manage လုပ်ဖို့ဆိုတာမှာ RHEL5 လို Python 2.4 ပဲပါတဲ့ Distribution တွေအတွက် Ansible 2.3 အထိ နှိမ့်ပြီးသုံးရမှာပါ။ ပြဿနာက Ansible Engine တင်ထားမယ့် Control Node မှာ ပုံမှန်အတိုင်းဆိုရင် Repository ထဲရှိတဲ့ Version က Ansible 2.4 အနိမ့်ဆုံးပါ။ အဲဒီတော့ Ansible 2.3 ရှိတဲ့ Repository ကိုထည့်ပြီးထပ်တင်မယ်ဆိုရင်လည်း Dependency ပြဿနာကရှိနေပြန်ပါလိမ့်မယ်။ Version တစ်ခုတည်းကိုပဲ Install လုပ်ခွင့်ရမှာဖြစ်ပါတယ်။ ဒါကြောင့် Version နှစ်မျိုးလုံးသုံးလို့ရအောင် Python ရဲ့ VirtualEnv နဲ့ environment ခွဲပြီး pip (Python Package Manager) ကနေ Install လုပ်တဲ့နည်းကအရှင်းဆုံးဖြစ်မှာပါ။ နမူနာအနေနဲ့တော့ RHEL/CentOS 7 ကိုပဲအခြေခံပြီး setup လုပ်ပြပေးပါမယ်။ တခြား distribution တွေမှာတော့ အနည်းငယ်ကွဲလွဲနိုင်ပါတယ်။&lt;/p&gt;

&lt;p&gt;pip အသုံးပြနိုင်ဖို့အတွက် လိုအပ်တဲ့ Package တွေအရင် install လုပ်ပါမယ်။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y python-setuptools python-devel gcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python-setuptools ထဲမှာပါဝင်တဲ့ easy_install ကိုအသုံးပြုပြီး pip ကို install လုပ်ပါမယ်။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo easy_install pip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Control Node တစ်ခုတည်းမှာ Ansible version တစ်ခုထက်ပိုပြီး ထည့်သွင်းအသုံးပြုနိုင်ဖို့အတွက် version တစ်ခုစီရဲ့ Library တွေကိုခွဲခြားထိန်းသိမ်းပေးနိုင်တဲ့ virtual environment (virtualenv) လိုအပ်ပါတယ်။ virtualenv ကိုတော့ pip ကနေတဆင့် ရယူပါမယ်။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ရလာတဲ့ virtualenv ကိုအသုံးပြုပြီး environment တည်ဆောက်ပါမယ်။ environment နာမည်ကိုတော့ ansible23 လို့ပေးလိုက်ပါမယ်။ ansible23 အစား အခြားနှစ်သက်ရာနာမည်ပေးနိုင်ပါတယ်။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtualenv ~/ansible23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;တည်ဆောက်လိုက်တဲ့ environment ကို ပြောင်းလဲအသုံးပြုနိုင်ဖို့ activate ဆိုတဲ့ script ဖိုင်ကို run ပေးရပါမယ်။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/ansible23/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ပြီးရင်တော့ လိုအပ်တဲ့ Ansible version ကို စတင် install လုပ်နိုင်ပါပြီ။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install ansible==2.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;လိုအပ်တဲ့ Ansible version ဟုတ်မဟုတ်ကို &amp;ndash;version option နဲ့ စစ်ဆေးနိုင်ပါတယ်။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ansible --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;environment ထဲကနေ ပြန်ထွက်ဖို့ကိုတော့ deactivate ဆိုတဲ့ command လေး run လိုက်ရုံပါပဲ။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deactivate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ဒီနည်းအတိုင်း Ansible 2.4 အတွက် နောက်ထပ် environment တစ်ခုတည်ဆောက်ပါမယ်။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtualenv ~/ansible24
source ~/ansible24/bin/activate
pip install ansible==2.4
ansible --version
deactivate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;လိုအပ်တဲ့ version တွေကို environment ခွဲပြီး install လုပ်ပြီးပြီဆိုရင်တော့ အသုံးပြုနိုင်ပါပြီ။
သုံးချင်တဲ့ Ansible version ရဲ့ environment ကို activate script လေး run ပြီးပြောင်းလိုက်ရုံပါပဲ။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/ansible23/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;တစ်ခုသတိထားရမှာက Managed Node တွေမှာ python-simplejson ဆိုတဲ့ package ရှိမနေရင် Ansible 2.3 ပြောင်းလဲအဆင်ပြေမှာမဟုတ်ပါဘူး။ &lt;code&gt;&amp;quot;Error: ansible requires the stdlib json or simplejson module, neither was found!&amp;quot;&lt;/code&gt; ဆိုတဲ့ Error Message တွေ့ရပါလိမ့်မယ်။ ဒါကြောင့် python-simplejson ကို install လိုက်လုပ်ပေးထားဖို့တော့လိုပါတယ်။&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;(၂)&lt;/strong&gt; RHEL 5 - Managed Node တွေမှာရှိတဲ့ Python ကို Version မြှင့်ဖို့အတွက်ကတော့ Extra Packages for Enterprise Linux (EPEL) Repository သုံးပြီး မြှင့်တဲ့နည်းက အလွယ်ကူဆုံးဖြစ်မှာပါ။&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://archives.fedoraproject.org/pub/archive/epel/epel-release-latest-5.noarch.rpm --no-check-certificate
wget https://archives.fedoraproject.org/pub/archive/epel/RPM-GPG-KEY-EPEL-5 --no-check-certificate
rpm --import RPM-GPG-KEY-EPEL-5
yum install -y epel-release-latest-5.noarch.rpm
yum install -y python26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python 2.6 ကို install လုပ်လိုက်တယ်ဆိုပေမယ့် Python 2.4 ကတော့ Default Interpreter အနေနဲ့ ပုံမှန်အတိုင်းဆက်ရှိနေမှာပါ။ တချို့ System Tools တွေက Python 2.4 နဲ့မှရမှာဖြစ်တဲ့အတွက် 2.6 ကို Upgrade လုပ်သွားတာမျိုးမဟုတ်ပဲ version ၂မျိုးလုံးတွဲပြီးရှိနေမှာဖြစ်ပါတယ်။ Ansible 2.4 နဲ့ Manage လုပ်တဲ့အခါ default ဖြစ်တဲ့ Python 2.4 ကို မသုံးပဲ 2.6 နဲ့ပြောင်းလဲအလုပ်လုပ်စေဖို့ကိုတော့ &lt;code&gt;ansible_python_interpreter&lt;/code&gt; ဆိုတဲ့ variable နဲ့ထည့်သွင်း ကြေငြာပေးဖို့လိုပါတယ်။ ဥပမာအနေနဲ့ inventory ဖိုင်ထဲမှာဆိုရင်တော့ -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[rhel5]
srv01.example.com	ansible_python_interpreter=/usr/bin/python26
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[rhel5]
srv01.example.com
srv02.example.com

[rhel5:vars]
ansible_python_interpreter=/usr/bin/python26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;စသဖြင့် ကြေငြာပေးလို့ရပါတယ်။&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;(၃)&lt;/strong&gt; နောက်ဆုံးနည်းလမ်းကတော့ Managed Node မှာရှိတဲ့ Python ကိုလုံးဝမသုံးပဲ သာမန် SSH နဲ့လှမ်းဝင်ပြီး Shell Command တွေ၊ Script တွေ Run သလိုမျိုး လုပ်ဆောင်ပေးတဲ့ Raw နဲ့ Script Module ကိုသုံးတဲ့နည်းပါပဲ။ ဒီနည်းလမ်းကိုသုံးပြီး Python version နိမ့်နေတဲ့ Managed Node တွေကို Python 2.6 install လုပ်ခိုင်းနိုင်ပါတယ်။&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;py26install.sh&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

wget https://archives.fedoraproject.org/pub/archive/epel/epel-release-latest-5.noarch.rpm --no-check-certificate
wget https://archives.fedoraproject.org/pub/archive/epel/RPM-GPG-KEY-EPEL-5 --no-check-certificate
rpm --import RPM-GPG-KEY-EPEL-5
yum install -y epel-release-latest-5.noarch.rpm
yum install -y python26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;py26install.yml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
- name: install python 2.6 in remote legacy system
  hosts: rhel5
  gather_facts: no

  tasks:
  - name: execute py26install.sh script on target system
    script:
      py26install.sh
  - name: execute raw command to check version
    raw:
      python26 -V 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python ကိုအခြေခံထားတဲ့ module တွေသုံးမရသည့်တိုင်အောင် shell command/script တွေကိုတိုက်ရိုက် run ပြီး Manage လုပ်နိုင်ပါတယ်။ Python version မကိုက်ညီတဲ့ပြဿနာရှိနေတာကြောင့် gather_facts ကိုတော့သုံးလို့ရမှာမဟုတ်ပါဘူး။ ဒါကြောင့် &lt;code&gt;gather_facts: no&lt;/code&gt; နဲ့ပိတ်ထားဖို့လိုပါတယ်။&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;အချုပ်အနေနဲ့ပြောရမယ်ဆိုရင်တော့ RHEL 5 လိုမျိုး Legacy System တွေကို မဖြစ်မနေ Ansible နဲ့ Automate လုပ်ရမယ်ဆိုရင် ဖော်ပြထားတဲ့နည်းလမ်းတွေထဲက အဆင်အပြေဆုံးနည်းလမ်းကိုသုံးလို့ရပါတယ်။ ဆယ်စုနှစ်တစ်ခုလောက် ပြဿနာမရှိပဲ run လာတဲ့ System မျိုးကို မထိရက်မကိုင်ရက်တာ နားလည်ပါတယ်။ သို့ပေမဲ့ November 30, 2020 မှာ Support ရပ်နားတော့မယ့် RHEL 5 ကို ဆက်လက်အသုံးပြုနိုင်အောင် ကြိုးစားနေတာထက် ဖြစ်နိုင်မယ်ဆိုရင် version အသစ်ကို ပြောင်းလဲအသုံးပြုဖို့ (Migration) စတင်ပြင်ဆင်တာကတော့ အကောင်းဆုံးဖြစ်မယ်လို ထင်မြင်မိပါတယ်။&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Reference: &lt;a href=&#34;https://www.ansible.com/blog/using-ansible-to-manage-rhel-5-yesterday-today-and-tomorrow&#34;&gt;Using Ansible to Manage RHEL 5 Yesterday, Today and Tomorrow&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scripting on Windows</title>
      <link>http://naingyeminn.com/posts/scripting-on-windows/</link>
      <pubDate>Sat, 09 Dec 2017 00:00:00 UTC</pubDate>
      <author>Naing Ye` Minn</author>
      <guid>http://naingyeminn.com/posts/scripting-on-windows/</guid>
      <description>&lt;p&gt;Linux နဲ့ပတ်သက်တာတွေပဲရေးဖြစ်တာများတဲ့အတွက် အပြောင်းအလဲလေးဖြစ်အောင် Windows နဲ့ ဖြတ်သန်းခဲ့တဲ့အချိန်တွေတုန်းကအကြောင်းအရာလေးကိုပြန်ပြောပါရစေ။&lt;/p&gt;

&lt;p&gt;Unix / Linux မှာတော့ Scripting ဆိုရင် သိပ်ရွေးနေစရာမလိုပါဘူး။ Bash script နဲ့ တော်တော်များများကိုဆောင်ရွက်နိုင်လို့ပါပဲ။ ဒီထက်ပိုလိုအပ်လာမယ်ဆိုရင်လဲ အများအားဖြင့် Python က တပါတည်းပါဝင်ပြီးသားဖြစ်လေ့ရှိတာကြောင့်လွယ်လယ်ကူကူအသုံးပြုနိုင်ပါတယ်။ Windows မှာကျ Batch script ဆိုတာရှိပေမဲ့ တကယ်တမ်းကျ ဘာမှမယ်မယ်ရရ သုံးလို့မရပါဘူး။ ဒါကြောင့် အများအားဖြင့် VBScript ကိုအသုံးပြုရပါတယ်။ VBScript က Windows ရဲ့ လုပ်ဆောင်ချက်တော်တော်များများကို ထိန်းချုပ်လို့ရတဲ့အတွက် အရမ်းကိုသုံးဝင်တဲ့ Scripting language တစ်ခုပါပဲ။ ဘယ်လောက်ထိအောင် အသုံးဝင်ခဲ့လဲဆိုရင် Windows XP ခေတ်မှာ USB Flash Drive တွေကနေကူးတဲ့ Virus တော်တော်များများက VBScript နဲ့ရေးထားတာတွေကို ကြုံခဲ့ရဖူးပါတယ်။ အဲဒီအချိန်တုန်းကတော့ VBScript နဲ့ရေးထားတဲ့ Virus တွေ့ရင်ကို အရမ်းပျော်ခဲ့မိတယ်။ ဘာလို့လဲဆိုတော့ Script တို့ရဲ့ထံုးစံအတိုင်း Binary အနေနဲ့ရှိနေတာမဟုတ်တဲ့အတွက် ရေးထားတဲ့ Coding ကို Text Editor နဲ့ဖွင့်ပြီး လွယ်လွယ်ကူကူလေ့လာလို့ရတာကြောင့်ပါပဲ။ တကူးတကကိုလိုက်စုတယ်။ သူ့ရဲ့ Behavior ကိုကြည့်ပြီး Removal Tool လေးတွေပြန်ရေးတယ်။ များသောအားဖြင့်က Script ကို System32 လိုနေရာမျိုးထဲကူးထည့်ပြီး Windows တက်လာတာနဲ့ အဲ့ဒီ Script ကို Run အောင် Registory ထဲဝင်ရေးထားလေ့ရှိတယ်။ ပြီးရင်တော့ စက်မှာတပ်လိုက်တဲ့ USB Drive တိုင်းရဲ့အထဲကို copy ကူးထည့်တယ်။ Drive ထဲရှိတဲ့ Data တွေကို ဝှက်ပစ်တယ်။ နောက် အခြားစက်မှာသွားတပ်လိုက်တာနဲ့ Drive ထဲကူးထည့်ထားတဲ့ Script ကို အလိုအလျောက် Run အောင် Autorun.inf ဆိုတဲ့ဖိုင်နဲ့ချိတ်ထားလေ့ရှိတယ်။ အမှန်ကတော့ VBScript အစွမ်းကြောင့်ဆိုတာထက် အဲ့ဒီ Autorun.inf ကြောင့်ပဲ Windows XP တွေမှာ ဒုက္ခရောက်ရတာလို့တောင်ပြောရမလိုပါ။ Autorun.inf ဆိုတာ CD/DVD တွေကို စက်ထဲထည့်လိုက်တာနဲ့ အခွေထဲပါတဲ့ Program ကို အလိုအလျောက် Run အောင်လုပ်ပေးတဲ့ File လေးပါ။ Windows ရဲ့ Feature တစ်ခုပါ။ အဲဒါကိုပဲအသုံးချပြီး USB Drive ထဲက Virus ကို run အောင်လုပ်ကြတာပါ။ အခုကတော့ Autorun တွေပိတ်ထားတာ၊ UAC (User Account Control) စတာတွေနဲ့ ထိန်းထားတာဖြစ်တဲ့အတွက် Windows XP တုန်းကလောက် မလွယ်ကူတော့ပါဘူး။ မူရင်းအကြောင်းအရာကိုပြန်သွားရမယ်ဆိုရင် VBScript နဲ့က တော်တော်လေးကိုအလုပ်ဖြစ်ပါတယ်။ ဒါပေမဲ့ အဲဒီအချိန်တွေတုန်းက အင်တာနက်ဆိုတာ သိပ်မတွင်ကျယ်သေးတာ့ VBScript ကိုလေ့လာဖို့အတွက်ကို Documentation ဖိုင်လေးပဲ အားကိုးရတာပါ။ Coding ကိုအစအဆုံး ကိုယ်တိုင်ရေးနိုင်တာထက် သူများရေးထားတာကို ကောင်းကောင်းဖတ်နိုင်ပြင်နိုင်တာလောက်ထိပဲခရီးရောက်လိုက်ပါတယ်။ ဘာလို့လဲဆိုတော့ VBScript ထက် လေ့လာရပိုလွယ်ပြီး ရေးရတာလည်း ပိုလွယ်တဲ့ AutoIt ကိုတွေ့ခဲ့တာကြောင့်ပါ။&lt;/p&gt;

&lt;p&gt;AutoIt က VBScript လိုပါပဲ။ ရေးရတဲ့ Syntax က BASIC နဲ့တူပါတယ်။ သူရဲ့အားသာချက်ကတော့ ရိုးရှင်းပြီးလေ့လာရလွယ်ကူတဲ့ Documentation ပါ။ တန်းပြီး run ကြည့်လို့ရတဲ့ Coding နမူနာလေးတွေပါတဲ့အတွက် အလုပ်လုပ်ပုံကို ပိုမိုနားလည်ရလွယ်ကူစေပါတယ်။ နောက်ပြီး VBScript နဲ့တော်တော်ခက်ခက်ခဲခဲရေးရမယ့်ဟာမျိုးတွေကို သူ့မှာ ၂ကြောင်း၃ကြောင်းလောက်ရေးရုံနဲ့အဆင်ပြေသွားအောင် ကြိုရေးပေးထားတဲ့ Library တွေစုံစုံလင်လင်ပါဝင်ပါတယ်။ သဘောအကျဆုံးအချက်ကတော့ Compile လုပ်ပြီး Binary(exe) အနေနဲ့ထုတ်လို့ရတာပါ။ VBScript ဆိုရင် Scripting Language တွေရဲ့သဘာဝအတိုင်း Text File တစ်ခုအနေနဲ့ရှိတာဖြစ်တဲ့အတွက် Coding ကိုမြင်နိုင်ပါတယ်။ AutoIt မှာကတော့ Script အနေနဲ့ Interpreter ကနေတဆင့် Run လို့ရသလို AutoIt interpreter သွင်းထားစရာမလိုပဲ Compile လုပ်လို့ထွက်လာတဲ့ exe ဖိုင်လေးကို ကြိုက်တဲ့စက်မှာ တန်း Run လို့ရပါတယ်။ Coding ရေးသားမှုအပိုင်းမှာကျတော့လည်း သီးသန့် Text Editor တစ်ခါတည်းပါလာပြီးသားပါ။ Text Editor ဆိုပေမဲ့ IDE တစ်ခုလို Syntax Hilighting တွေ၊ Test Run လုပ်ကြည့်တာ၊ Build/Compile လုပ်တာတွေပါဝင်ပါတယ်။ AutoIt နဲ့ဘာတွေလုပ်ခဲ့ဖူးသလဲဆိုရင် အဓိကကတော့ Windows မှာသုံးများတဲ့ Software တွေရဲ့ Installation Setup တွေမှာ Next Next Ok စသဖြင့်မနှိပ်ချင်တဲ့အတွက် Automate လုပ်တာတွေများတယ်။ Windows တင်ပြီးတာနဲ့ လိုအပ်တဲ့ Software တွေကို အလိုအလျောက်သွင်းသွားအောင်လုပ်တာမျိုးပါ။ နောက်ပြီး သူငယ်ချင်းတွေကိုစဖို့ အတွက် program လေးတွေလုပ်ဖြစ်တယ်။ မှတ်မှတ်ရရဆိုရင် One Missed Call ဆိုတဲ့သရဲကားထဲက တီးလုံးသံတွေကို timer ပေးပြီး ဖွင့်ခိုင်းတာမျိုးတွေ၊ နောက်ပြီး အဲဒီအချိန်က အင်တာနက်ဆိုင်တွေမှာ Key Logger တွေကိုကြောက်ရတဲ့အတွက် Gtalk ကိုဖွင့်လိုက်တာနဲ့ Login ဝင်ဖို့ကို username တလှည့် password တလှည့်ရိုက်ပြီး keystroke တွေရောသွားအောင်လုပ်ပေးတဲ့ဟာမျိုးလေးတွေ စသဖြင့် စိတ်ကူးတည့်ရာလေးတွေတော်တော်လုပ်ဖြစ်တယ်။ ပြောရရင် AutoIt က Windows ပေါ်မှာ အရမ်းကိုမွှေလို့ကောင်းတဲ့ Language လေးပါ။&lt;/p&gt;

&lt;p&gt;AutoIt အကြောင်းပြန်ပြောဖြစ်တာကတော့ အလုပ်မှာ လက်တလော ပြန်သုံးလိုက်ရလို့ပါပဲ။ Windows စက်တွေထဲက Data ကို Linux Server ပေါ် Backup အနေနဲ့ Upload လုပ်တာရယ်၊ Upload လုပ်ပြီးသား Data တွေကို Windows စက်ပေါ်မှာ အချိန်အတိုင်းအတာတစ်ခုထိထားထားပြီးမှရှင်းလင်းရေးလုပ်ချင်တာရယ်ပါ။ Linux Server ပေါ်တင်မှာဖြစ်တဲ့အတွက် Server Side ကတော့ ပြဿနာမရှိပါဘူး။ SSH ကနေတဆင့် လှမ်းပို့ရင်ရပါတယ်။ Windows ဘက်မှာကျတော့ အရေးကြီးတဲ့ စက်ဖြစ်တဲ့အတွက် Software တွေ Install လုပ်လို့ မလိုအပ်ပဲ ရှုပ်ထွေးကုန်မှာကိုမဖြစ်စေချင်တာပါ။ Windows ပေါ်မှာ အတတ်နိုင်ဆုံး Standalone run နိုင်ဖို့လိုအပ်ပါတယ်။ ဒါကြောင့် ပထမဦးဆုံးကြိုးစားကြည့်တာကတော့ Batch Script နဲ့ပါ။ Batch ချည်းသီးသန့်တော့မဟုတ်ပါဘူး။ SSH ကနေတဆင့် Data transfer လုပ်ဖို့အတွက် &lt;strong&gt;PuTTY&lt;/strong&gt; ထဲမှာပါတဲ့ &lt;strong&gt;pscp&lt;/strong&gt; Console Application လေးကိုသုံးတာပါ။ နောက်တစ်ခုက Data ကိုပို့တဲ့အခါ ဖိုင်တစ်ဖိုင်ချင်းကို connection တစ်ခုစီဖွင့်ပြီးပို့တာထက် အကုန်လုံးကိုစုပြီး compressed archive တစ်ခုလုပ်ပို့တာက Windows ဘက်မှာ Overhead နည်းစေပါတယ်။ ဒါကြောင့် Compress လုပ်ဖို့ 7Zip ရဲ့ &lt;strong&gt;7za&lt;/strong&gt; ဆိုတဲ့ Console Application လေးနဲ့ထပ်တွဲသုံးလိုက်ပါတယ်။ &lt;strong&gt;pscp&lt;/strong&gt; နဲ့ Linux Server ထဲကူးထည့်လိုက်တဲ့ဖိုင်ရဲ့ Integrity ကိုစစ်ဖို့ကိုတော့ &lt;strong&gt;plink&lt;/strong&gt; ကနေတဆင့် &lt;strong&gt;md5sum&lt;/strong&gt; ထုတ်ခိုင်းပြီးပြန်တိုက်စစ်ပါတယ်။ အားလုံးအဆင်ပြေပေမဲ့ Scheduler နဲ့ အချိန်သတ်မှတ်ပြီး Batch script ကို Run ခိုင်းတဲ့အခါကျ CMD Prompt တစ်ချက်ပေါ်ပြီးပြန်ပိတ်ပါတယ်။ ပုံမှန်ဆိုရင်တော့ ပြဿနာမရှိပေမဲ့ အဲဒီ Windows ပေါ်မှာ Run ထားတဲ့ အဓိက Software ကို interrupt ဖြစ်ဖြစ်သွားစေတဲ့အတွက် အဆင်မပြေပါဘူး။ နောက်ပြီး Backup သိမ်းမယ့် Linux Server ဘက်အပိုင်းမှာ Server ပြောင်းထားချင်တာ၊ Backup Directory ကိုပြောင်းချင်တာတို့အတွက်ကျ Batch ထဲမှာဝင်ပြင်တဲ့အခါ လွဲချော်ပြီး Script က အလုပ်မလုပ်တော့တာမျိုးတွေဖြစ်သွားနိုင်ပါတယ်။ ဒါကြောင့် Batch အစား VBScript သုံးဖို့စဉ်းစားကြည့်ပါသေးတယ်။ လုပ်ချင်တာတွေက AutoIt မှာပိုလွယ်တဲ့အတွက်ကြောင့် AutoIt ကိုပဲရွေးဖြစ်သွားပါတယ်။ &lt;strong&gt;pscp&lt;/strong&gt;, &lt;strong&gt;plink&lt;/strong&gt; နဲ့ &lt;strong&gt;7za&lt;/strong&gt; ကို Script ထဲထည့်သုံးတာကမခက်ပါဘူး။ ပိုသေသပ်ပြီး environment လွယ်လွယ်ကူကူပြောင်းလို့ရအောင် config ဖိုင်သီးသန့်ခွဲထုတ်တဲ့အပိုင်းနဲ့ Backup File ကိုပို့တဲ့နေရာမှာ ည၁၂နာရီကျော်မှ ပြီးခဲ့တဲ့ရက်က File ကိုပို့ဖို့ရယ်၊ Backup လုပ်ပြီးသား ဖိုင်တွေကို Clean up လုပ်ဖို့ ဘယ်နှစ်ရက်ကြာရင် ဖျက်မယ်ဆိုတာရယ်ကို File တွေရဲ့ Modified Date နဲ့တွက်တဲ့အပိုင်းလောက်ပဲ စဉ်းစားရပါတယ်။&lt;/p&gt;

&lt;p&gt;ဒီ Script လေးကို BackupIt လို့နာမည်ပေးထားပြီး &lt;a href=&#34;https://github.com/naingyeminn/BackupIt&#34;&gt;GitHub&lt;/a&gt; မှာတင်ပေးထားပါတယ်။ Configuration ဖိုင်ဖြစ်တဲ့ config.ini ထဲမှာလိုအပ်တဲ့ data လေးတွေဖြည့်ပေးပြီးတာနဲ့ BackupIt.exe ဖိုင်လေးကို Task Scheduler မှာ ထည့်ပြီး run ခိုင်းလိုက်ရုံပါပဲ။ &lt;code&gt;config.ini&lt;/code&gt; ထဲဖြည့်ပေးရမယ့် data တွေကတော့ -&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[General]&lt;/strong&gt; =&amp;gt; Backup Server ရဲ့ Information ရေးရမယ့် Section ပါ။&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;user&lt;/strong&gt;  =&amp;gt; SSH Login အတွက် အသုံးပြုမယ့် User Name&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pass&lt;/strong&gt; =&amp;gt; SSH Login Password (PuTTY ၏ SSH Private Key ဖြစ်တဲ့ .ppk File အသုံးပြုနိုင်ပါတယ်။ Program နှင့် Directory အတူတူထားပေးဖို့လိုအပ်ပါတယ်)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;host&lt;/strong&gt; =&amp;gt; Linux Server ရဲ့ IP (သို့) Host Name&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;port&lt;/strong&gt; =&amp;gt; SSH အသုံးပြုမယ့် Port Number (အလွတ်ထားထားရင် 22 ကိုပဲ သုံးပါတယ်)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;time&lt;/strong&gt; =&amp;gt; ချိတ်ဆက်မယ့် Linux Server ကို ping မရရင် ထပ်မံကြိုးစားမယ့်အချိန်ပမာဏ (အလွတ်ထားရင် ချိတ်လို့မရမချင်း ကြိုးစားနေပါလိမ့်မယ်)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;wait&lt;/strong&gt; =&amp;gt; တစ်ကြိမ် Ping မရတိုင်း စောင့်မယ့်မိနစ် (အလွတ်ထားရင် 1 မိနစ်ပါ)&lt;/p&gt;

&lt;p&gt;General Section ကတော့ Config ထဲမဖြစ်မနေပါရမယ့် အပိုင်းလေးပါ။ Config ဖိုင်ရဲ့ထိပ်ဆုံးမှာ ရေးပေးဖို့တော့လိုပါတယ်။ ပြီးရင်တော့ Backup လုပ်မယ့် File တွေ Directory တွေရဲ့ Information ကို ကိုယ့်စိတ်ကြိုက် Section name ပေးပြီးရေးလို့ရပါတယ်။&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[images]&lt;/strong&gt; =&amp;gt; General မဟုတ်တဲ့ တခြား ကြိုက်တဲ့ နာမည်ပေးလို့ရပါတယ်။ Backup Archive ဖိုင် ထုတ်တဲ့နေရာမှာ Section Name ကို ထည့်သွင်းအသုံးပြုမှာပါ။&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;path&lt;/strong&gt; =&amp;gt; Backup လုပ်မယ့် Directory Path (ညွှန်းထားတဲ့ Directory အောက်မှာရှိတဲ့ Data တွေကို Backup လုပ်မှာပါ)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;name&lt;/strong&gt; =&amp;gt; ရွေးယူလိုတဲ့ ဖိုင်နာမည် ( IMAGES*, *.log, etc. အလွတ်ထားရင် File အားလုံး (&lt;strong&gt;*&lt;/strong&gt;) ဖြစ်ပါတယ်)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt; အမျိုးအစား (0 = Files &amp;amp; Directories, 1 = Files, 2 = Directories)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dest&lt;/strong&gt; =&amp;gt; Linux Server ဘက်မှာရှိတဲ့ Directory Path&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pday&lt;/strong&gt; =&amp;gt; Backup Data စတင်ပါဝင်မည့်ရက် (အလွတ်ထားရင် 1 ပါ။ မနေ့ကရက်ကိုဆိုလိုတာပါ။)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nday&lt;/strong&gt; =&amp;gt; Backup Data နောက်ဆုံးပါဝင်မည့်ရက် (အလွတ်ထားရင် လက်ရှိရက်ကိုပဲဆိုလိုတာပါ။ 0 နဲ့အတူတူပါပဲ။)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pday&lt;/strong&gt;, &lt;strong&gt;nday&lt;/strong&gt; မပြောထားရင် Program ကို run တဲ့ရက်မတိုင်ခင်တစ်ရက်က Data တွေကို Archive လုပ်သွားမှာပါ။ အထက်မှာရေးထားတဲ့အတိုင်းဆိုရင်တော့ လွန်ခဲ့တဲ့ ၇ရက်ကနေ Program ကို run တဲ့နေ့ရဲ့ ည ၁၂နာရီမတိုင်ခင်က Data တွေကို စုပြီး Archive လုပ်သွားမှာဖြစ်ပါတယ်။&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;retn&lt;/strong&gt; =&amp;gt; Retention (path မှာညွှန်းထားတဲ့ Directory ထဲမှာရှိတဲ့ Data တွေကို သတ်မှတ်ထားတဲ့ရက်အရေအတွက်လောက်သိမ်းထားပြီး ဒီထက်ဟောင်းတဲ့ Data တွေကိုတော့ ဖျက်မှာပါ။ အလွတ်ထားရင် Data အဟောင်းတွေကိုမဖျက်ပါဘူး။)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;rtyp&lt;/strong&gt; =&amp;gt; Retention အရ ဖျက်မယ့် Data အမျိုးအစား (0 = Original Data &amp;amp; Archives, 1 = Original Data Only, 2 = Archives Only. အလွတ်ထားရင် 0 ပါ။)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ovrw&lt;/strong&gt; =&amp;gt; Archive File ကို Overwrite လုပ်/မလုပ် (အလွတ်ထားရင် 1 ပါ။ Overwrite လုပ်ပါလိမ့်မယ်။ 0 ပေးထားရင်တော့ Archive File Name ကို create လုပ်တဲ့ Date/Time နဲ့ တွဲပြီးပေးပါလိမ့်မယ်။)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[General]
user=sshuser01
pass=pass-123
host=192.168.1.1
port=22
time=3

[data]
path=D:\MyData
name=Works
type=2
dest=/home/sshuser01/Backup/Data
retn=3
rtyp=2
ovrw=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows ပေါ်မှာ ဒီ configuraiton အတိုင်းရေးပြီး Program ကို run လိုက်တာနဲ့ &lt;code&gt;D:\MyData&lt;/code&gt; ထဲမှာရှိတဲ့ Directory တွေထဲကမှ &lt;code&gt;Work&lt;/code&gt; ဆိုတဲ့ Directory ကို 7zip နဲ့ compress လုပ်ပြီး Linux Server ဖြစ်တဲ့ &lt;code&gt;192.168.1.1&lt;/code&gt; ပေါ်ကို SSH ကနေတဆင့် copy ကူးတင်သွားမှာပါ။ Linux Server ပေါ်မှာသိမ်းမယ့်လမ်းကြောင်းကတော့ &lt;code&gt;&#39;/home/sshuser01/Backup&#39;&lt;/code&gt; ဖြစ်ပါတယ်။ &lt;code&gt;ovrw=0&lt;/code&gt; ပေးထားတဲ့အတွက် Program run လိုက်တိုင်း Archive ဖိုင်တွေကို &lt;code&gt;D:\MyData&lt;/code&gt; အောက်ထဲမှာ နာမည်ခွဲပြီးသိမ်းပေးသွားမှာပါ။ ဥပမာ - &lt;code&gt;data_20171208173004.7z&lt;/code&gt; ဆိုတဲ့နာမည်မျိုးနဲ့သိမ်းသွားမှာဖြစ်ပါတယ်။ Overwrite မဖြစ်တဲ့အတွက် ဖိုင်တွေကအများကြီးဖြစ်လာပါလိမ့်မယ်။ ဒါကိုပြန်ထိန်းချုပ်ဖို့အတွက် &lt;code&gt;retn=3&lt;/code&gt; လို့ပေးထားတာပါ။ &lt;strong&gt;7z&lt;/strong&gt; ဖိုင်တွေဘယ်လောက်ပဲများများ ၃ရက်ထက်ပိုပြီးသိမ်းမထားပါဘူး။ ၃ရက်ကျော်ကြာတဲ့ဖိုင်တွေကို Program run တဲ့အချိန်မှာ ဖျက်ပစ်သွားမှာဖြစ်ပါတယ်။ &amp;lsquo;General&amp;rsquo; section ထဲက &lt;code&gt;time=3&lt;/code&gt; ကတော့ Backup process မလုပ်ခင် Server ကို Ping ကြည့်ပါလိမ့်မယ်။ Ping မရရင် ၁မိနစ်စောင့်ပြီး နောက်တစ်ခါထပ် Ping ကြည့်မှာပါ။ ၃ခါ Ping လို့မှမရရင်တော့ ထပ်ကြိုးစားတော့မှာမဟုတ်ပါဘူး။ အကယ်၍များ ၁မိနစ်မဟုတ်ဘဲ ၅မိနစ်စောင့်ပြီးမှ ထပ် Ping စေချင်ရင်တော့ &amp;lsquo;General&amp;rsquo; section အောက်ထဲမှာ &lt;code&gt;wait=5&lt;/code&gt; လို့ထည့်ပေးလိုက်ရုံပါပဲ။&lt;/p&gt;

&lt;p&gt;Logic နဲ့ Process Flow ကိုတော့ &lt;code&gt;BackupIt.au3&lt;/code&gt; Script ဖိုင်လေးကိုကြည့်ပြီး လေ့လာနိုင်ပါတယ်။ AutoIt က Basic Programming Knowledge လေးရှိရုံနဲ့ လွယ်လွယ်ကူကူလေ့လာလို့ရတဲ့ Scripting Language လေးတစ်ခုပါ။ Linux ကိုစလေ့လာတဲ့အချိန် Shell Scripting ပိုင်းမှာ အခက်အခဲမရှိတာ AutoIt ရဲ့ကျေးဇူးတွေ တော်တော်လေးပါတယ်လို့တောင်ပြောလို့ရပါတယ်။ အခုနောက်ပိုင်း Windows မှာ PowerShell ထပ်ပါလာပေမဲ့ Syntax ပုံစံအနည်းငယ်ရှုပ်ထွေးတာရယ် command တွေမှာ Option တွေရေးရတာအရမ်းရှည်တာတွေရယ်ကြောင့် အမှန်အတိုင်းပြောရရင် Windows မှာအားသာချက်တစ်ခုတိုးလာတယ်လို့ ခုချိန်ထိမမြင်မိသေးပါဘူး။ Windows ရဲ့ Configuration ကို Script ရေးပြီးလုပ်လို့ရလာလို့သာဝမ်းသာမိတာပဲရှိပါတယ်။ ဒါပေမဲ့ Windows Server ပိုင်းကို အာရုံစိုက်ပြီးလေ့လာမယ့်သူတွေအတွက်ဆိုရင်တော့ PowerShell က မဖြစ်မနေလေ့လာထားသင့်တယ်လို့တော့ပြောချင်ပါတယ်။ Scripting/Programming ရဲ့ သဘောတရားကိုသိထားပြီးသူတစ်ယောက်အနေနဲ့တော့ ဘာ Language ပဲသုံးသုံးအခက်အခဲရှိမှာမဟုတ်ပါဘူး။ သဘောတရားကိုပိုင်နိုင်ဖို့အတွက်ကတော့ စိတ်ကူးတည့်ရာလေးတွေ ရေးစမ်းကြည့်ဖို့လိုပါလိမ့်မယ်။ နောက်တစ်ခုက သူများရေးထားတဲ့ Code တွေကိုကြည့်ပြီး ဘယ်ဟာက ဘာကြောင့်ရေးတယ်ဆိုတာကို နားလည်အောင်ကြိုးစားကြည့်ဖို့အကြံပေးချင်ပါတယ်။ ဒါမှသာ Coding Idea လေးတွေရပြီး ကိုယ်ရေးတဲ့ Code ထဲ ထည့်သွင်းအသုံးချနိုင်မှာဖြစ်ပါတယ်။ ဒါကြောင့် Windows နဲ့ ဖြတ်သန်းခဲ့တဲ့နေ့ရက်တွေကို အမှတ်ရရင်း ရေးထားတဲ့ AutoIt Script လေးကို ဒီ Post လေးနဲ့ မျှဝေလိုက်ရပါတယ်။&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GitHub: &lt;a href=&#34;https://github.com/naingyeminn/BackupIt&#34;&gt;BackupIt&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
