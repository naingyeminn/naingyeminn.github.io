<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Naing Ye` Minn</title>
    <link>http://naingyeminn.com/tags/linux/</link>
    <description>Recent content in Linux on Naing Ye` Minn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 12 Dec 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://naingyeminn.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Optimizing Ansible Playbooks: Parallelism</title>
      <link>http://naingyeminn.com/posts/ansible-parallelism/</link>
      <pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/ansible-parallelism/</guid>
      <description>Ansible ကိုလေ့လာနေသူတွေအနေနဲ့ Playbook တွေ၊ Ad-hoc command တွေနဲ့ Task တွေကို Host အများကြီးမှာ တစ်ပြိုင်တည်း (Parallel) လုပ်ဆောင် (run) ခိုင်းလို့ရတယ်ဆိုတာတော့ သိကြပြီးဖြစ်မှာပါ။ ဒါပေမဲ့ တစ်ပြိုင်းတည်းဆိုတိုင်း delegate လုပ်လိုက်တဲ့ Host အကုန်လုံးမှာ တန်းပြီး run တာတော့ မဟုတ်ပါဘူး။ ကနဦးသတ်မှတ်ထားတဲ့ (Default) အရေအတွက်က Host ၅လုံးကိုပဲ တပြိုင်တည်းလုပ်ဆောင်ပေးတာပါ။ Host ၁၀လုံးမှာ Task တွေ run ခိုင်းတယ်ဆိုရင် ၅လုံးတစ်ဖြတ်ဖြတ်ပြီးပဲ run မှာပါ။ ပိုရှင်းအောင်ပြောရမယ်ဆိုရင် ဥပမာ - Linux Server ၁၀ လုံးမှာ ၅လုံးကို အရင် SSH နဲ့လှမ်းချိပ်မယ်၊ ပြီးရင် Playbook ထဲရေးထားတဲ့ Task တွေကို အဲ့ဒီ ၅လုံးမှာအရင် run မယ်၊ Task အားလုံးပြီးသွားတော့မှ နောက်ကျန်တဲ့ ၅လုံးကို ထပ်ချိပ်ပြီး ထပ် run တာဖြစ်ပါတယ်။ ဒီလို run ပေးခြင်းက Host တွေရဲ့ လုပ်ဆောင်နိုင်စွမ်း (Performance) ကို မထိခိုင်အောင်ကာကွယ်ပေးနိုင်လို့ပါပဲ။ အလွယ် ဥပမာပေးရမယ်ဆိုရင် Server အလုံး ၅၀ လောက်ကို Update လုပ်မယ်ဆိုပါစို့။ ၅လုံးတစ်ဖြတ်စီသာခွဲမ run ပေးရင် အလုံး ၅၀ လုံးက တစ်ပြိုင်တည်း Update တွေလှမ်းဆွဲပြီး Network traffic မှာ အလုပ် အရမ်း များသွားပါလိမ့်မယ်။ Server တွေမှာလည်း Update ပမာဏ (Size) များရင်များသလို မြန်မြန်ဆန်ဆန် ရသင့်သလောက်မရတော့ပဲ ပိုကြာသွားတာမျိုးဖြစ်သွားပါလိမ့်မယ်။ နောက်တစ်ခုက VM Environment အနေနဲ့ Hypervisor Host တစ်လုံးတည်းပေါ်မှာရှိနေတဲ့ VM တွေအကုန်လုံးမှာ CPU အသုံးပြုမှုများနိုင်တဲ့ Task တစ်ခုခုကို run တဲ့အခါ ၅လုံးစီခွဲ run ခြင်းက Hypervisor Host ရဲ့ Performance ထိခိုက်မှုကို ကာကွယ် လျှော့ချပြီးသားဖြစ်သွားပါလိမ့်မယ်။ မဟုတ်ရင် VM တွေအကုန်လုံးက တပြိုင်တည်း အလုပ်တွေလုပ်ပြီး Hypervisor Host ရဲ့ CPU မှာ Load အရမ်းများသွားပါလိမ့်မယ်။ ဒါပေမဲ့ မေးခွန်းထုတ်စရာရှိတာက Resource အရမ်းမလိုတဲ့ Task မျိုးတွေကို run တဲ့အခါကျ ၅လုံးစီမဟုတ်ပဲ အလုံး ၅၀၊ ၁၀၀ တစ်ပြိုင်တည်း run ပေးလိုက်ရင်ပိုမမြန်နိုင်ဘူးလားဆိုတာပါပဲ။ Control Node အနေနဲ့ အဲဒီလောက်များတဲ့ session တွေကို ထိန်းသိမ်းပေးနိုင်တဲ့ Resource Capacity (CPU, Memory) လုံလုံလောက်လောက် ရှိတယ်ဆိုရင်ရပါတယ်။ ဥပမာ Ansible Tower အသုံးပြုတယ်ဆိုရင် သူ့ရဲ့ Memory Requirement က Host အလုံး ၁၀၀ ကို manage လုပ်နိုင်ဖို့အတွက် အနည်းဆုံး 4GB ရှိသင့်ပါတယ်။ Ansible Engine မှာလည်း ဒီအတိုင်းပါပဲ။ Capacity တွက်ချက်မှုအတွက် ထည့်သွင်းစဉ်းစားရမယ့် အချက် (Factor) တွေရှိပါတယ်။ ဒီအပိုင်းကိုတော့ နောက်မှသီးသန့်ထပ်ရေးပေးပါမယ်။</description>
    </item>
    
    <item>
      <title>Optimizing Ansible Playbooks: Delegation</title>
      <link>http://naingyeminn.com/posts/ansible-delegation/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/ansible-delegation/</guid>
      <description>ဒီတစ်ခါတော့ Ansible ကိုလေ့လာနေကြတဲ့သူတွေအတွက် ကောင်းမွန်တဲ့ Ansible Playbook တစ်ခုရဖို့ Optimize လုပ်တဲ့အခါ သိထားသင့်တဲ့ နည်းလမ်းလေးတွေကိုမျှဝေချင်ပါတယ်။ ပထမဦးဆုံးအနေနဲ့ သိစေချင်တဲ့အချက်ကတော့ Delegation ပဲဖြစ်ပါတယ်။ မြန်မာလိုဆီလျော်အောင်ပြောမယ်ဆိုရင်တော့ တာဝန်ပေးတယ်လို့ဆိုရပါလိမ့်မယ်။ Ansible Playbook ဆိုတာ တကယ်တော့ ဆောင်ရွက်စေချင်တဲ့ လုပ်ငန်းဆောင်တာ (Task) တွေကို အစီအစဉ်တကျ ရေးသားထားတဲ့ စာသားဖိုင် (Text File) လေးတွေပါ။ ဒီ Task တွေကို ဘယ် server၊ ဘယ် device မှာလုပ်ဆောင်ခိုင်းမယ်ဆိုတာကို hosts ဆိုတဲ့ keyword နဲ့ကြေငြာပေးရပါတယ်။ Playbook ရေးကြည့်ဖူးတဲ့သူတွေဆိုရင်သိပါလိမ့်မယ်။ ဥပမာအနေနဲ့ ဒီ Playbook ကိုကြည့်ကြည့်ပါ။
 play - one ဆိုတဲ့ Play တစ်ခုကနေ vm01.example.com ဆိုတဲ့ Host ပေါ်မှာ task တစ်ခု run ခိုင်းထားတာပါ။ အဓိကသတိထားမိစေချင်တာက myvar နဲ့ ansible_nodename ဆိုတဲ့ Variable တွေပဲဖြစ်ပါတယ်။ myvar ကတော့ play - one ဆိုတဲ့ play ရဲ့ variable ဖြစ်ပြီး ansible_nodename ကတော့ vm01.</description>
    </item>
    
    <item>
      <title>Managing RHEL5 with Ansible</title>
      <link>http://naingyeminn.com/posts/managing-rhel5-with-ansible/</link>
      <pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/managing-rhel5-with-ansible/</guid>
      <description>လွန်ခဲ့တဲ့ တစ်ပတ်လောက်က မိတ်ဆွေအကိုတွေနဲ့အလုပ်ကိစ္စစကားထိုင်ပြောနေရင်း Ansible အကြောင်းရောက်သွားတယ်။ သူတို့ရုံးရဲ့ Server တွေကို Ansible နဲ့ စမ်းပြီး Manage လုပ်ကြည့်နေတာမှာ ကြုံရတဲ့ ပြဿနာတစ်ခုကိုပြောပြတယ်။ သုံးထားတဲ့ Server OS တွေက RHEL 5, 6, 7 အစုံဖြစ်နေတာကြောင့် Playbook တစ်ခုတည်းနဲ့ ပေါင်းပြီး run လိုက်တဲ့အခါကျ version အနိမ့်ဖြစ်တဲ့ RHEL 5 မှာအဆင်မပြေပဲ error တွေတက်တာပါ။ အဲ့ဒီတုန်းကတော့ connection type (Paramiko ကိုသုံးဖို့လိုတာ) ကြောင့်လို့ပဲထင်လိုက်မိတာ တကယ်တမ်းသေချာအောင် လိုက်ရှာဖတ်ကြည့်တော့မှ Ansible Version နဲ့ Managed Node ရဲ့ Python Version နဲ့မကိုက်တာကြောင့်မှန်းသိရတယ်။ အဲ့တော့ ဒီပြဿနာကိုဖြေရှင်းဖို့က နည်းလမ်း သုံးခုတော့ရှိပါတယ်။ (၁) Ansible Version အနိမ့်နဲ့ Manage လုပ်ရင်လုပ်၊ (၂) Managed Node ရဲ့ Python ကို Version မြှင့်ရင်မြှင့်၊ (၃) Ansible ရဲ့ Python မလိုတဲ့ RAW Module နဲ့ Script Module ကိုသုံးရင်သုံး၊ ဒီနည်းလမ်းတွေနဲ့ဖြေရှင်းလို့ရပါတယ်။</description>
    </item>
    
    <item>
      <title>iSCSI with Multipath in CentOS7</title>
      <link>http://naingyeminn.com/posts/iscsi-with-multipath-in-centos7/</link>
      <pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/iscsi-with-multipath-in-centos7/</guid>
      <description>iSCSI (Internet Small Computer Systems Interface) ဆိုတာ SAN (Storage Area Network) Protocol တစ်ခုပါ။ အလွယ်ပြောရရင် Computer တစ်လုံးမှာရှိတဲ့ Storage Device/Space ကို အခြား Computer တစ်လုံးရဲ့ Block Device/Hard Disk အနေနဲ့ Network ကနေတဆင့် ဆွဲယူချိပ်ဆက်အသုံးပြုတဲ့အခါမှာသုံးပါတယ်။ iSCSI ရဲ့အားသာချက်ကတော့ သာမန် IP Network ပေါ်မှာအလုပ်လုပ်တာဖြစ်ပြီး Fiber Channel လို SAN Switch မလိုအပ်ပါဘူး။ Network ပေါ်ကနေတဆင့် ချိပ်ဆက်အသုံးပြုတာဖြစ်တဲ့အတွက် အကယ်၍များ Network Link ပြတ်တောက်သွားခဲ့ရင် ပြဿနာတက်နိုင်ပါတယ်။ ဒါကြောင့် Network Link ကို တစ်ခုထဲအသုံးပြုတာထက် ၂ခုအနည်းဆုံးထားပြီး ချိပ်ဆက်မှသာ High Availability ဖြစ်မှာပါ။ ဒီလိုချိပ်ဆက်ခြင်းမျိုးကို Multipath လို့ခေါ်ခြင်းဖြစ်ပါတယ်။ အခု ဒီ Video လေးမှာတော့ CentOS 7 ပေါ်မှာ iSCSI Drive ကို Multipath သုံးပြီး ဘယ်လိုချိပ်ဆက်မလဲဆိုတာကို ပြသပေးထားပါတယ်။</description>
    </item>
    
    <item>
      <title>Scheduling Linux Tasks</title>
      <link>http://naingyeminn.com/posts/scheduling-linux-tasks/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/scheduling-linux-tasks/</guid>
      <description> Linux Tutorials - Myanmar &amp;ldquo;at&amp;rdquo; command အသုံးပြုပုံ   &amp;ldquo;cron&amp;rdquo; အသုံးပြုပုံ   &amp;ldquo;anacron&amp;rdquo; အသုံးပြုပုံ   </description>
    </item>
    
    <item>
      <title>Executing Commands Remotely via SSH</title>
      <link>http://naingyeminn.com/posts/executing-commands-remotely-via-ssh/</link>
      <pubDate>Wed, 28 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/executing-commands-remotely-via-ssh/</guid>
      <description>SSH ကို Remote Login အတွက် SysAdmin တိုင်းသုံးကြပါတယ်။ ဒါပေမဲ့ Remote Execution အတွက်တော့ သိပ်သုံးလေ့မရှိကြပါဘူး။ စာသင်တဲ့အခါ သင်တန်းသားတွေကိုမေးကြည့်တော့လည်း တချို့တွေက Remote Login လောက်ပဲသုံးဖူးကြတာတွေ့ရတဲ့အတွက်ဒီ Post လေးရေးဖြစ်သွားတာပါ။ Server ထဲကို SSH သုံးပြီး Login ဝင်၊ ပြီးမှ ကိုယ် run ချင်တဲ့ command run တာ၊ ပြင်ချင်တဲ့ config ပြင်တာတွေကို လုပ်ကြတာများပါတယ်။ အမှန်က သုံးချင်တဲ့ command ကို SSH ကနေတဆင့် တန်း run လို့ရပါတယ်။ ဥပမာ -
$ ssh user1@server1.example.com ls -l /  server1.example.com ဆိုတဲ့ server ထဲကို user1 ဆိုတဲ့ user account နဲ့ Login ဝင်ပြီး ls -l / ဆိုတဲ့ command ကို run တာမျိုးပါ။</description>
    </item>
    
    <item>
      <title>Using SED Command</title>
      <link>http://naingyeminn.com/posts/using-sed-command/</link>
      <pubDate>Sun, 08 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/using-sed-command/</guid>
      <description>sed ဆိုတာ Stream Editor အတိုကောက်ပါ။ command တစ်ခုခုရဲ့ output text stream ကိုဖြစ်စေ၊ file ထဲက text တွေကိုဖြစ်စေ ရှာဖွေခြင်း၊ ပြင်ဆင်ခြင်းများပြုလုပ်နိုင်ပါတယ်။ grep, awk တို့နဲ့အမြဲတွဲသုံးလေ့ရှိပါတယ်။ sed ကိုလေ့လာဖို့ ထုံးစံအတိုင်း လိုအပ်တဲ့ဖိုင်လေးတစ်ခုပြုလုပ်ပါမယ်။
#Yangon Regions # Htaukkyant Mhawbi Hlegu Taikgyi Okkan Apyauk Htantabin Shwepyaytha HlaingTharyar DagonMyothit Thanlyin Kyauktan Thonegwa KhaYan Twante Kawthmu Kungyangon CocoIsland Yangon  ပေးထားတဲ့ Text ကို Text Editor တစ်ခုခုထဲ ကူးထည့်ပြီး ygn.txt နာမည်နဲ့ Desktop ပေါ်မှာ Save လုပ်လိုက်ပါ။
sed command ရဲ့ အခြေခံအသုံးပြုပုံကတော့ အောက်ပါအတိုင်းဖြစ်ပါတယ်။
sed [option] &#39;commands&#39; file_to_edit  အခု ygn.</description>
    </item>
    
    <item>
      <title>Using AWK Command</title>
      <link>http://naingyeminn.com/posts/using-awk-command/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/using-awk-command/</guid>
      <description>Text File ထဲက Content တွေကိုရှာဖွေတဲ့နေရာမှာ grep အပြင် နောက်ထပ်သုံးလေ့သုံးထရှိတာကတော့ awk ဖြစ်ပါတယ်။ Content ရှာတာခြင်တူပေမဲ့ Output ကို Delimiter (သတ်မှတ်ပိုင်းခြားသင်္ကေတ) သုံးပြီးလိုအပ်တဲ့အပိုင်းလောက်ပဲ ခွဲထုတ်ပြသပေးနိုင်တာ သူ့ရဲ့အားသာချက်တစ်ခုပါ။ Default Delimiter ကတော့ Space ဖြစ်ပါတယ်။ Space ခြားထားတဲ့နေရာတွေကနေပိုင်းခြားပြသပေးမှာဖြစ်ပါတယ်။ လက်တွေ့လေ့လာစမ်းသပ်နိုင်ဖို့ လိုအပ်တဲ့ နမူနာ ဖိုင်လေးတစ်ခုအလျှင်ဦးဆုံး ဖန်တီးပါမယ်။
အောက်မှာပေးထားတဲ့စာသားတွေကို နှစ်သက်ရာ Text Editor တစ်ခုခုထဲကူထည့်ပြီး awktest.txt ဆိုတဲ့နာမည်နဲ့ Desktop ပေါ်မှာ Save လုပ်လိုက်ပါ။
1 MaungMaung Yangon 2000Ks 2 KyawKyaw Bago 2500Ks 3 AyeAye Bago 2500Ks 4 AungAung Pyay 2000Ks 5 MaungHla Yangon 3000Ks 6 KoKo Yangon 3000Ks 7 AyeMaung Bagan 3500Ks  awk command မှာတော့ အပိုင်းသုံးပိုင်းရှိပါတယ်။ Pattern, Procedure နှင့် File တို့ပဲဖြစ်ပါတယ်။</description>
    </item>
    
    <item>
      <title>Using GREP Command</title>
      <link>http://naingyeminn.com/posts/using-grep-command/</link>
      <pubDate>Sun, 01 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/using-grep-command/</guid>
      <description>Unix/Linux ကိုလေ့လာနေသူတွေအနေနဲ့ မသိမဖြစ်တဲ့ Command လေးတစ်ခုပါ။ Text File, Config File, Log File နှင့် Command တစ်ခုကနေထွက်လာတဲ့ Output စတာတွေထဲကမှ လိုအပ်တဲ့ information ကို ရှာဖွေထုတ်ယူတဲ့အခါမျိုးမှာ သုံးလေ့ရှိပါတယ်။ ဘယ်လောက်ထိ အသုံးဝင်၊ အသုံးတည့်တယ်ဆိုတာကတော့ အသုံးချမှုပေါ်မူတည်ပါလိမ့်မယ်။ လေ့လာရလွယ်ကူစေဖို့အတွက် lab environment တစ်ခုပြုလုပ်ကြပါမယ်။ ဒီ Post မှာတော့ Mac OS X အသုံးပြုပြီး ပြပေးထားတာပါ။ ဒါပေမယ့် Linux မှာလည်း အတူတူပါပဲ။
အလျှင်ဦးဆုံး Text Editor တစ်ခုခုသုံးပြီး အောက်မှာ ဖော်ပြထားတဲ့ စာသားတွေပါဝင်တဲ့ Text File တစ်ခုကို Desktop ပေါ်မှာတည်ဆောက်လိုက်ပါ။ File Name ကိုတော့ grep_demo.txt လို့ပေးပြီး Save လုပ်လိုက်ပါ။
a quick brown fox jumps over the lazy dog. A QUICK BROWN FOX JUMPS OVER THE LAZY DOG.</description>
    </item>
    
    <item>
      <title>Coloring Log Files</title>
      <link>http://naingyeminn.com/posts/coloring-log-files/</link>
      <pubDate>Wed, 14 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/coloring-log-files/</guid>
      <description>Linux Administrator တွေအနေနဲ့ Log Analyzer တွေမျိုးစုံရှိနေပေမယ့် တစ်ခါတစ်ရံ လိုအပ်လို့ Log File တွေကိုမွှေနှောက်ရမယ်ဆိုလျှင် အာရုံနောက်ကြမယ်ထင်ပါတယ်။ Log File တွေရဲ့ထုံးစံအတိုင်း Text တွေကို ပြွပ်သိပ်နေအောင်ရိုက်ထုတ်ထားတာဖြစ်တဲ့အတွက် ဖတ်ရတဲ့သူအတွက် ဘယ်အပိုင်းက ဘာဆိုတာကို မနည်း အာရုံစိုက်ခွဲခြားနေရပါလိမ့်မယ်။ အဲဒီပြဿနာကိုတော့ CCZE ကကူညီဖြေရှင်းပေးနိုင်ပါတယ်။ CCZE ဆိုတာကတော့ command-line tool လေးတစ်ခုပဲဖြစ်ပါတယ်။ Linux Admin တွေအနေနဲ့ server ကို ssh နဲ့ access လုပ်နေတဲ့အချိန် Log File တွေကိုဖတ်ရှုဖို့လိုလာခဲ့မယ်ဆိုလျှင်တော့ ဒီ Tool လေးက အရမ်းအသုံးတည့်ပါတယ်။ Log ကိုသက်ဆိုင်ရာ အပိုင်းအခြားအလိုက် အရောင်ခွဲခြားပြီး ပြသပေးတာဖြစ်တဲ့အတွက် ဖတ်ရှုသူအနေနဲ့ မြန်ဆန်လွယ်ကူစွာ နားလည်သဘောပေါက်နိုင်မှာပါ။
Debian/Ubuntu မှာတော့ -
$ sudo apt-get install -y ccze  ဆိုပြီး Install တန်းလုပ်လို့ရပါတယ်။
RHEL/CentOS/Fedora စတဲ့ Distro တွေမှာတော့ EPEL ကနေ Install ပြုလုပ်နိုင်ပါတယ်။</description>
    </item>
    
    <item>
      <title>EPEL for CentOS</title>
      <link>http://naingyeminn.com/posts/epel-for-centos/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/epel-for-centos/</guid>
      <description>EPEL ဆိုတာ Extra Packages for Enterprise Linux ရဲ့ အတိုကောက်ပါ။ Extra Packages ဆိုတဲ့အတိုင်း CentOS ရဲ့ Main Repository ထဲမပါဝင်ပေမယ့် အသုံးဝင်တဲ့ Package တွေကို စုစည်းပေးထားတဲ့ Repository တစ်ခုပါ။ Fedora Project ရဲ့ပံ့ပိုးမှုနဲ့ ဖြစ်ပေါ်လာတဲ့ Project တစ်ခုဖြစ်ပြီး Fedora Linux အတွက်တင်မဟုတ်ဘဲ Fedora-based ဖြစ်တဲ့ Red Hat Enterprise Linux နဲ့ တခြား မျိုးနွယ်တူ CentOS, Scientific Linux စတာတွေအတွက်ပါ Support ပေးထားတဲ့ Repo ပဲဖြစ်ပါတယ်။ အသေးစိပ်ကိုတော့ EPEL/FAQ မှာလေ့လာနိုင်ပါတယ်။
EPEL ထဲက package တွေကို Install ပြုလုပ်ချင်တယ်ဆိုလျှင်တော့ EPEL Repo ကို YUM Package Manager ရဲ့ Repo List ထဲမှာ ထပ်ထည့်ပြီး Enable ပြုလုပ်ပေးရပါမယ်။ အဲဒီအတွက် EPEL Package ကို Install လုပ်ရပါမယ်။ EPEL Package ကိုတော့ Distro Version ပေါ်မူတည်ပြီး Download ယူဖို့လိုပါတယ်။ Download အတွက် wget command ကိုအသုံးပြုမှာဖြစ်တဲ့အတွက် ကြိုတင် Install လုပ်ထားဖို့လိုပါလိမ့်မယ်။</description>
    </item>
    
    <item>
      <title>Reading Man Page</title>
      <link>http://naingyeminn.com/posts/reading-man-page/</link>
      <pubDate>Wed, 02 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/reading-man-page/</guid>
      <description>Unix/Linux Admin တစ်ယောက်အနေနဲ့ ရပ်တည်ဖို့ဆိုလျှင် Terminal နဲ့ Command တွေကိုကောင်းကောင်းသုံးတတ်ဖို့လိုတယ်ဆိုတာ အားလုံးသိကြမှာပါ။ သို့ပေမယ့် အရှိန်အဟုန်နဲ့ တိုးတက်နေတဲ့ နည်းပညာခေတ်ကြီးမှာ အသစ်ထွက်သမျှ Program တွေ၊ အဲဒီ Program တွေရဲ့ Command တွေကို အကုန်သိ၊ အကုန်မှတ်မိနေဖို့ဆိုတာ ခက်ခဲလွန်းပါတယ်။ အလွတ်ကျက်ပြီး မှတ်ထားတယ်ဆိုလျှင်တောင်မှ နောင်ထွက်လာတဲ့ Version အသစ်မှာ Option တွေ Usage တွေ ပြောင်းသွားနိုင်ပါတယ်။ အဲဒီအခါမျိုးကျ ပြန်လည်မှတ်သားဖို့လိုပါလိမ့်မယ်။ အလွယ်ဆုံးနဲ့ အမြန်ဆုံး လေ့လာနိုင်မယ့်နည်းလမ်းကတော့ Man Page လို့ခေါ်တဲ့ Manual Page ပါပဲ။
Man Page တနည်းအားဖြင့် man ဆိုတဲ့ command ကို Unix/Linux Distro တိုင်းလိုလိုမှာ Install လုပ်လိုက်တာနဲ့ တခါတည်း ပါဝင်လာပြီးသားပါ။ man ရဲ့ အဓိကလုပ်ဆောင်ချက်ကတော့ Developer တွေ သူတို့ Program တွေနဲ့ တပါတည်း ရေးသားပြစုထည့်သွင်းပေးလိုက်တဲ့ Documentation ဖိုင်တွေကို ထုတ်ယူဖော်ပြပေးတာပါပဲ။ ဒီလို Program တွေ Command တွေအတွက် Documentation တွေပြုလုပ်တဲ့နေရာမှာ စံအနေနဲ့ အကြောင်းအရာအလိုက် Section Number ခွဲခြားသတ်မှတ်ပေးထားတာရှိပါတယ်။ အဲဒါတွေကတော့ -</description>
    </item>
    
    <item>
      <title>Find Command Usage</title>
      <link>http://naingyeminn.com/posts/find-command-usage/</link>
      <pubDate>Thu, 27 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/find-command-usage/</guid>
      <description>အခုနောက်ပိုင်း Linux မှာက GUI သုံးပြီးအလွယ်တကူ Search လုပ်လို့ရနေတော့ find ဆိုတဲ့ command ကို သိပ်မသုံးဖြစ်ကြပါဘူး။ သို့ပေမယ့် ပိုမိုတိကျတဲ့ result ရရှိဖို့အတွက်ကျတော့ find ကအရမ်းအသုံးဝင်ပါတယ်။ Linux Admin တွေအနေနဲ့ သိထားသင့်တဲ့ command လေးဖြစ်တဲ့အတွက် အသုံးပြုပုံတချို့ကို ဖော်ပြပေးလိုက်ပါတယ်။
File Name ဖြင့်ရှာဖွေခြင်း  /etc အောက်မှာရှိတဲ့ .conf နဲ့ဆုံးတဲ့ ဖိုင်တွေကိုပဲရှာချင်တယ်ဆိုလျှင်တော့  $ find /etc -name &amp;quot;*.conf&amp;quot;   command မှာပါတဲ့ * (Asterik) လေးကတော့ wildcard character ပါ။ .conf ရှေ့မှာ ဘာ character ရှိရှိလို့ ဆိုလိုခြင်းဖြစ်ပါတယ်။
  File name စာလုံး အကြီး၊ အသေး မရွေးစေချင်လျှင်တော့ -iname ဆိုတဲ့ option ကိုသုံးနိုင်ပါတယ်။ -name နဲ့ကွာခြားပုံကို အောက်မှာဖော်ပြထားတဲ့ နမူနာအတိုင်း စမ်းကြည့်နိုင်ပါတယ်။ -name option သုံးရင် hello ဆိုတဲ့တစ်ဖိုင်ပဲတွေ့ရမှာဖြစ်ပြီး -iname နဲ့ဆိုလျှင်တော့ ၃ ဖိုင်လုံးတွေ့ရပါလိမ့်မယ်။  $ mkdir testing $ cd testing $ touch hello HelloGuys HelloThere $ find .</description>
    </item>
    
    <item>
      <title>Linux Terminal / Command Line Tricks (2)</title>
      <link>http://naingyeminn.com/posts/linux-command-line-usage-2/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/linux-command-line-usage-2/</guid>
      <description>Linux/Unix ရဲ့ Bash Shell Terminal မှာ command တွေကို မြန်မြန်ဆန်ဆန် Edit လုပ်နိုင်စေမယ့် Shortcut လေးတွေပါ။ ရိုက်လိုက်တဲ့ command တစ်ကြောင်းမှာ အမှားပါနေလို့ပြန်ပြင်မယ်ဆိုရင် ကိုယ်တွေလုပ်နေကျ သမရိုးကျနည်းလမ်းအတိုင်း Arrow key တွေနဲ့ ရှေ့နောက်ရွှေ့ Delete, Backspace တို့နဲ့ပြန်ဖျက်၊ ပြန်ရေးနဲ့ အချိန်ကြာပါတယ်။ အခုထုတ်နှုတ်ပေးထားတဲ့ Shortcut လေးတွေသိထားမယ်ဆိုရင်တော့ command တွေကို မြန်မြန်ဆန်ဆန်ရိုက်နိုင် ပြင်နိုင်မှာဖြစ်တဲ့အတွက် အလုပ်ပိုတွင်ပါလိမ့်မယ်။ Linux/Unix Admin တွေအနေနဲ့ မဖြစ်မနေ သိထားသင့်တဲ့ Shortcut လေးတွေပဲဖြစ်ပါတယ်။
Command Editing Shortcuts  Control + a : Command အစသို့
 Control + e : Command အဆုံးသို့
 Control + k : Cursor နေရာမှစ၍ Command အဆုံးထိဖျက်</description>
    </item>
    
    <item>
      <title>Linux Terminal / Command Line Tricks</title>
      <link>http://naingyeminn.com/posts/linux-command-line-usage/</link>
      <pubDate>Sun, 03 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/linux-command-line-usage/</guid>
      <description>Linux User တွေအနေနဲ့ သိထားသင့်တဲ့ Terminal အသုံးပြုပုံလေးတွေပါ။ အပြည့်အစုံကြီး မဟုတ်ပေမယ့် အသုံးဝင်တဲ့ နည်းလမ်းလေးတချို့ကိုပဲ အသုံးများတဲ့ Ubuntu ပေါ်အခြေခံပြီး အဓိကထားမျှဝေလိုက်ပါတယ်။
Shortcuts   Terminal အသစ်ဖွင့် Control + Alter + T   Tab အသစ်ဖွင့် Control + Shift + T   Zoom In (စာလုံးကြီး) Control + Shift + = (Control + +)   Zoom Out (စာလုံးသေး) Control + -   Copy Control + Shift + C   Paste Control + Shift + V   Command အစသို့ Control + A   Command ဖျက် Control + U</description>
    </item>
    
    <item>
      <title>Tips for Ubuntu-MM</title>
      <link>http://naingyeminn.com/posts/tips-for-ubuntu-mm/</link>
      <pubDate>Thu, 03 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/tips-for-ubuntu-mm/</guid>
      <description>$ Terminal မှ User ၏ Command Prompt ကိုဆိုလိုခြင်းဖြစ်သည်။ Online မှ Blog များ Tutorial များတွင် Command များကိုဖော်ပြရာ၌ ထည့်သွင်းဖော်ပြလေ့ရှိသည်။ သို့သော် ထို Command အား ကူးယူ အသုံးပြုရာတွင် ထည့်သွင်းအသုံးပြုစရာမလိုပါ။ $ sudo apt-get update ဟုဖော်ပြထားပါက sudo apt-get update ဆိုသော command သာကူယူအသုံးပြုရန်လိုအပ်သည်။
$ အား စာလုံးတစ်ချို့နှင့် ကပ်၍အသုံးပြုထားပါက shell variable အဖြစ် သတ်မှတ်ထားသည်ကို ပြန်လည်ခေါ်ယူ အသုံးပြုခြင်းဖြစ်သည်။
$ var=&amp;quot;Hello&amp;quot; $ echo $var Hello  အဆိုပါဥပမာရှိ line တစ်ခုချင်း၏ ရှေ့တွင်တွေ့ရသော $ သည် Command Prompt ကိုဆိုလိုခြင်းဖြစ်ပြီး ဒုတိယ line တွင်ပြထားသော $var သည် shell variable ကိုဆိုလိုခြင်းဖြစ်သည်။</description>
    </item>
    
    <item>
      <title>vFix - Fix Virus Infected Flash Drives</title>
      <link>http://naingyeminn.com/posts/vfix-fix-virus-infected-flash-drives/</link>
      <pubDate>Mon, 23 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/vfix-fix-virus-infected-flash-drives/</guid>
      <description>ရုံးမှာ တစ်ခါတစ်ခါ Virus ဝင်ထားတဲ့ Flash Drive တွေ ယူယူလာ Data တွေမတွေ့တော့လို့ဆိုပြီး လာပြလေ့ရှိပါတယ်။ များသောအားဖြင့် Windows Virus တွေက Flash Drive ကနေပဲ ကူးကြတာများပါတယ်။ ကူးပြီဆိုရင်လဲ Drive ထဲရှိတဲ့ Folder တွေကို Hidden လုပ် Folder နဲ့ နာမည်တူ Link တွေထုတ်ပြီး virus file ကိုသွားချိတ်လေ့ရှိပါတယ်။ Windows မှာရှိတဲ့ Antivirus က Virus ကိုရှင်လိုက်နိုင်တယ်ဆိုရင်တောင် အဲဒီ Virus က Hidden လုပ်သွားတဲ့ Flash Drive ထဲက Folder တွေကိုတော့ ပြန်ဖေါ်ပေးလေ့မရှိပါဘူး။
အကယ်၍များ Linux မှာ အဲ့ Drive ကိုသွားသုံးမယ်ဆိုရင်တော့ Hidden ဖြစ်နေတဲ့ Folder တွေကိုမြင်ရပါလိမ့်မယ်။ Drive ထဲ Virus ရှိနေသေးတယ်ဆိုရင်တောင် အဲဒီ Windows က Virus တွေက Linux ပေါ်မှာအလုပ်မလုပ်ပါဘူး။ လိုတာက အဲဒီ Virus ဖိုင်( .</description>
    </item>
    
    <item>
      <title>XenServer Installation Problems and Review</title>
      <link>http://naingyeminn.com/posts/xenserver-installation-problems-and-review/</link>
      <pubDate>Fri, 30 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://naingyeminn.com/posts/xenserver-installation-problems-and-review/</guid>
      <description>မနေ့က အလုပ်မှာ Desktop တစ်လုံးအပိုထွက်လာတာနဲ့ XenServer စမ်းကြည့်ဖြစ်တယ်။ စက်က အမြင့်ကြီးမဟုတ်ပေမယ့် processor က VT support လုပ်တာရယ် Memory 4GB လောက်ရှိတာရယ်ကြောင့် စမ်းဖို့အဆင်ပြေသွာတယ်။ XenServer 6.2 iso လဲဆွဲထားပြီးသားရှိပေမယ့် CD အလွတ်မရှိတာနဲ့ Flash Drive နဲ့ပဲ install လုပ်မယ်ပေါ့။ အဲ့ဒီအတွက် flash drive ကို FAT32 နဲ့ format ချ၊ Unetbootin နဲ့ ပုံမှန်အတိုင်းပဲ XenServer ISO ကို extract လုပ်လိုက်တာ ဖြစ်ချင်တော့ boot တက်တဲ့အချိန်မှာ kernel ရှာမရပါဘူးဆိုပြီး error ပြလာတယ်။ google မှာရှာကြည့်လိုက်တော့ USB drive ရဲ့ /boot/isolinux/ directory ထဲက isolinux.cfg ကို syslinux.cfg ဆိုပြီး တော့ရယ်၊ /boot/ ထဲက isolinux ကို syslinux ဆိုပြီး ပြောင်းပေးရတယ်။ နောက် /syslinux.</description>
    </item>
    
  </channel>
</rss>